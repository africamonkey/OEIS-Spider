{
    "number": 252849,
    "data": "4,8,9,12,18,20,24,25,27,28,36,40,44,45,49,50,52,54,56,60,63,64,68,72,75,76,84,88,90,92,98,99,100,104,108,116,117,120,121,124,125,126,128,132,135,136,140,144,147,148",
    "name": "Numbers with an even number of square divisors.",
    "comment": [
        "Closed lockers in the locker problem where the student numbers are the set of perfect squares.",
        "The locker problem is a classic mathematical problem. Imagine a row containing an infinite number of lockers numbered from one to infinity. Also imagine an infinite number of students numbered from one to infinity. All of the lockers begin closed. The first student opens every locker that is a multiple of one, which is every locker. The second student closes every locker that is a multiple of two, so all of the even-numbered lockers are closed. The third student opens or closes every locker that is a multiple of three. This process continues for all of the students.",
        "A variant on the locker problem is when not all student numbers are considered; in the case of this sequence, only the square-numbered students open and close lockers. The sequence here is a list of the closed lockers after all of the students have gone."
    ],
    "link": [
        "Reinhard Zumkeller, <a href=\"/A252849/b252849.txt\">Table of n, a(n) for n = 1..10000</a>",
        "K. A. P. Dagal, <a href=\"http://arxiv.org/abs/1307.6455\">Generalized Locker Problem</a>, arXiv:1307.6455 [math.NT], 2013.",
        "B. Torrence and S. Wagon, <a href=\"https://cms.math.ca/crux/v33/n4/page232-236.pdf\">The Locker Problem</a>, Crux Mathematicorum, 2007, 33(4), 232-236."
    ],
    "mathematica": [
        "Position[Length@ Select[Divisors@ #, IntegerQ@ Sqrt@ # &] & /@",
        "Range@ 150, _Integer?EvenQ] // Flatten (* _Michael De Vlieger_, Mar 23 2015 *)"
    ],
    "program": [
        "(C++)",
        "#include <iostream>",
        "using namespace std;",
        "int main()",
        "{",
        "  const int one_k = 1000;",
        "  //all numbers in sequence up to one_k are given",
        "  int lockers [one_k] = {};",
        "  int A = 0;",
        "  while (A < one_k) {",
        "    lockers [A] = A+1;",
        "     A = A + 1;",
        "  }",
        "  int B = 1;",
        "  while ( ((B+1) * (B+1)) <= one_k) {",
        "    int C = ((B+1) * (B+1));",
        "    int D = one_k/C;",
        "    int E = 1;",
        "    while (E <= D) {",
        "      lockers [(C*E)-1] = -1 * lockers [(C*E)-1];",
        "      E = E + 1;",
        "    }",
        "    B = B + 1;",
        "  }",
        "  int F = 0;",
        "  while (F < one_k) {",
        "    if (lockers [F] < 0) {",
        "      cout << (-1 * lockers [F]) << endl;",
        "    }",
        "    F = F + 1;",
        "  }",
        "  return 0;",
        "}  /* _Walker Dewey Anderson_, Mar 22 2015 */",
        "(PARI) isok(n) = sumdiv(n, d, issquare(d)) % 2 == 0; \\\\ _Michel Marcus_, Mar 22 2015",
        "(Haskell)",
        "a252849 n = a252849_list !! (n-1)",
        "a252849_list = filter (even . a046951) [1..]",
        "-- _Reinhard Zumkeller_, Apr 06 2015"
    ],
    "xref": [
        "Cf. A000290, A252895.",
        "Cf. A046951."
    ],
    "keyword": "nonn",
    "offset": "1,1",
    "author": "_Walker Dewey Anderson_, Mar 22 2015",
    "references": 2,
    "revision": 40,
    "time": "2015-04-06T21:12:27-04:00",
    "created": "2015-04-06T16:54:29-04:00"
}