{
    "number": 255597,
    "data": "1,1,3,29,1667,3254781,10650037396483",
    "name": "Upper bound on the number of different Euler diagrams for n classes.",
    "comment": [
        "Obtained via an iterative method. Each new class added to an existing diagram must create at least a new zone, and at most a number of new zones equal to the existing zones."
    ],
    "link": [
        "<a href=\"http://math.stackexchange.com/questions/863844/how-many-euler-diagrams-with-n-sets-exist\">Discussion on Stack Exchange</a>"
    ],
    "formula": [
        "a(n) = Sum_{k=1..inf} e(n,k), where k is the number of zones, and the elements e(n,k) are defined recursively as: e(0,1) = 1; e(n,k) = Sum_{c=1..k-1) binomial(c,k-c)*e(n-1,c)."
    ],
    "example": [
        "For n=3 (3 different classes) there are 29 possible Euler diagrams that do not reduce to smaller cases. Of these 11 are in fact repetitions and need to be eliminated to perfect the upper bound."
    ],
    "program": [
        "#include <stdio.h>",
        "#include <stdlib.h>",
        "#include <math.h>",
        "#define  MAXCLU        7",
        "#define MAXZONE      256",
        "long long combi(int n,int k)",
        "{     if (n<k) return 0;",
        "      long long ans=1;",
        "      k=k>n-k?n-k:k;",
        "      int j=1;",
        "      for(;j<=k;j++,n--)",
        "        {  if(n%j==0)",
        "            { ans*=n/j;}",
        "           else if(ans%j==0)",
        "            { ans=ans/j*n;}",
        "           else",
        "            { ans=(ans*n)/j;}",
        "        }",
        "      return ans;",
        "}",
        "int main()",
        "{",
        "  long long  a[MAXCLU][MAXZONE];",
        "  long long sum[MAXCLU];",
        "  int j,k,i;",
        "  for (j=0;j<MAXCLU;j++)",
        "      {",
        "       sum[j]=0;",
        "       for (k=1;k<MAXZONE;k++) a[j][k]=0;",
        "      }",
        "  a[0][1] = 1;",
        "  for(j=1;j<MAXCLU;j++)",
        "       for (k=1;k<(exp2(j)+1);k++)",
        "            for (i=1;i<k;i++)",
        "                  a[j][k] = a[j][k] + a[j-1][i]*combi(i,k-i);",
        "  for (j=0;j<MAXCLU;j++)",
        "       for (k=1;k<exp2(j)+1;k++)",
        "            sum[j]= sum[j] + a[j][k];",
        "  for (k=0;k<=exp2(MAXCLU-1);k++)",
        "      { for (j=0;j<MAXCLU;j++)",
        "         { if (j<5)",
        "             {",
        "              if (k==0) printf(\"%5lld\",sum[j]);",
        "              else printf(\"%5lld\",a[j][k]);",
        "             }",
        "           else",
        "            { if (k==0) printf(\"%15lld\",sum[j]);",
        "              else printf(\"%15lld\",a[j][k]);",
        "            }",
        "         }",
        "   printf(\"\\n\");",
        "   if (k==0) printf(\"\\n\");",
        "}",
        "}"
    ],
    "xref": [
        "This sequence is linked to A007018 by the binomial transform: b(n)=SUM(C(n,k)a(k), k=0..n)."
    ],
    "keyword": "nonn",
    "offset": "0,3",
    "author": "_Maurizio De Leo_, Feb 27 2015",
    "references": 0,
    "revision": 14,
    "time": "2015-03-25T20:18:18-04:00",
    "created": "2015-03-25T20:18:18-04:00"
}