{
    "number": 278638,
    "data": "6,12,15,18,20,21,24,28,30,33,35,36,40,42,44,45,48,52,54,55,56,60,63,65,66,68,70,72,75,76,77,78,80,84,85,88,90,91,95,96,99,100,102,104,105,108,110,112,114,115,117,119,120,126,130,132,133,135,136,138,140,143,144,145,147,150,152,153",
    "name": "Numbers n such that 1/n is a difference of Egyptian fractions with all denominators < n.",
    "comment": [
        "Numbers n such that we can write 1/n = Sum_{1<=k<n} c(k)/k with all c(k) in {-1,0,1}.",
        "Numbers n such that A072207(n) < 2*A072207(n-1).",
        "If n is in the sequence, so is k*n for all k>1.",
        "Contains A001284, because 1/(m*k) = 1/(m*(k-m))-1/(k*(k-m)).",
        "Disjoint from A000961.",
        "2*p^k with p prime is in the sequence if and only if p=3.",
        "3*p^k with p prime is in the sequence if and only if p=2,5,7 or 11.",
        "4*p^k with p prime is in the sequence if and only if p=3,5,7,11,13,17 or 19.",
        "For each m, there are only finitely many primes p such that some m*p^k is in the sequence."
    ],
    "link": [
        "Robert Israel, <a href=\"/A278638/b278638.txt\">Table of n, a(n) for n = 1..431</a>",
        "Robert Israel, <a href=\"/A278638/a278638_1.txt\">Examples for n = 1..431</a>"
    ],
    "example": [
        "44 is in the sequence because 1/44 = (1/12 + 1/33) - 1/11.",
        "4 is not in the sequence because 1/4 can't be written as the difference of sums of two subsets of {1, 1/2, 1/3}."
    ],
    "maple": [
        "N:= 200: # to get all terms <= N",
        "V:= Vector(N):",
        "f:= proc(n)  option remember;",
        "local F,E,p,e,k,m,L,L1,i,s,t,sg,Maybe;",
        "global Rep;",
        "  F:= numtheory:-factorset(n);",
        "  if nops(F) = 1 then return false fi;",
        "  if ormap(m -> n < m^2 and m^2 < 2*n, numtheory:-divisors(n)) then",
        "    for m in numtheory:-divisors(n) do",
        "      if n < m^2 and m^2 < 2*n then",
        "        k:= n/m; Rep[n]:= [m*(k-m),-k*(k-m)]; return true",
        "      fi",
        "    od",
        "  fi;",
        "  F:= convert(F,list);",
        "  E:= map(p -> padic:-ordp(n,p), F);",
        "  i:= max[index](zip(`^`,F,E));",
        "  p:= F[i];",
        "  e:= E[i];",
        "  k:= n/p^e;",
        "  Maybe:= false;",
        "  for i from 3^(k-1) to 2*3^(k-1)-1 do",
        "    L:= (-1) +~ convert(i,base,3);",
        "    s:= 1/k - add(L[i]/i,i=1..k-1);",
        "    if numer(s) mod p = 0 then",
        "    Maybe:= true;",
        "      t:= abs(s/p^e); sg:= signum(s);",
        "      if  (numer(t) <= 1 and (denom(t) < n or (denom(t) < N and V[denom(t)] = 1))) or (numer(t) = 2 and denom(t) < N and V[denom(t)] = 1) then",
        "         L1:= subs(0=NULL, [seq(L[i]*i*p^e,i=1..k-1)]);",
        "         if t = 0 then ;",
        "         elif numer(t) = 1 and denom(t) < n then L1:= [op(L1),sg/t]",
        "         elif procname(2/t) then",
        "            L1:= ([op(L1), 2*sg/t, op(expand(sg*Rep[2/t]))])",
        "         else next",
        "         fi;",
        "         if max(abs~(L1)) < n then Rep[n]:= L1; return true fi;",
        "      fi;",
        "    fi",
        "  od:",
        "  if Maybe then printf(\"Warning: %d is uncertain\\n\",n)",
        "else false",
        "fi;",
        "end proc:",
        "for n from 6 to N do",
        "  if V[n] = 0 and f(n) then",
        "    V[n] := 1;",
        "    for j from 2*n to N by n do",
        "      if not assigned(Rep[j]) then",
        "        V[j]:= 1;",
        "        Rep[j] := map(`*`,Rep[n],j/n);",
        "        f(j):= true;",
        "      fi",
        "    od;",
        "  fi;",
        "od:",
        "select(t -> V[t]=1,[$6..N]);"
    ],
    "xref": [
        "Cf. A000961, A001284, A072207.",
        "Contains A005279. _Robert G. Wilson v_, Nov 27 2016"
    ],
    "keyword": "nonn",
    "offset": "1,1",
    "author": "_Robert Israel_, Nov 24 2016",
    "references": 1,
    "revision": 30,
    "time": "2016-11-27T21:18:30-05:00",
    "created": "2016-11-27T21:18:30-05:00"
}