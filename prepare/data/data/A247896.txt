{
    "number": 247896,
    "data": "29,43,61,67,89,167,227,239,263,269,281,349,367,389,439,457,461,463,487,499,521,563,601,607,613,641,643,647,653,677,683,821,827,983,1063,1229,1277,1283,1289,1361,1367,1423,1427,1429,1447,1481,1483,1489,1549,1601",
    "name": "Primes that produce a different prime when one of its digits is added to it.",
    "comment": [
        "From an idea of Eric Angelini (see seqfan link).",
        "Digit 0 is not considered because the new primes must be different from the starting numbers. Therefore, 101 is not part of the sequence, because the only prime that results from adding one of its digits is 101 + 0 = 101, which is the same number, while 601 is acceptable because 601 + 6 = 607, a prime."
    ],
    "link": [
        "Paolo P. Lava, <a href=\"/A247896/b247896.txt\">Table of n, a(n) for n = 1..1000</a>",
        "Eric Angelini, <a href=\"http://list.seqfan.eu/pipermail/seqfan/2014-August/013432.html\"> Primes adding one of their digit to themselves (+chains) </a>"
    ],
    "example": [
        "The number 29 is prime, and 29 + 2 = 31 is also prime.",
        "The same with 487, which produces 487 + 4 = 491, a prime."
    ],
    "maple": [
        "P:=proc(q) local a,b,k,n,ok;",
        "for n from 1 to q do a:=ithprime(n); ok:=0;",
        "for k from 1 to ilog10(a)+1 do",
        "b:=trunc((a mod 10^k)/10^(k-1)); if b>0 then",
        "if isprime(a+b) then ok:=1; break; fi; fi; od;",
        "if ok=1 then print(a); fi; od; end: P(10^6);"
    ],
    "program": [
        "(PARI) /* Description: Generates a vector containing this kind of terms between m^u1 and m^u2 for this definition applied by adding base B digits to the original number in decimal. Here (u1,m,B)=(1,3,10) by default. */",
        "LstThem(u2,u1=1,m=3,B=10)={",
        "  my(L:list=List(),y);",
        "  forprime(x=m^u1,m^u2,",
        "    y=vecsort(digits(x,B),,8);",
        "    if(sum(j=1,#y,y[j]&&isprime(x+y[j])),",
        "      listput(L,x)));",
        "  vector(#L,i,L[i])} \\\\ _R. J. Cano_, Sep 27 2014",
        "(Haskell)",
        "a247896 n = a247896_list !! (n-1)",
        "a247896_list = filter f a000040_list where",
        "   f p = any ((== 1) . a010051') $",
        "             map (+ p) $ filter (> 0) $ map (read . return) $ show p",
        "-- _Reinhard Zumkeller_, Sep 27 2014"
    ],
    "xref": [
        "Cf. A047791, A048519.",
        "Cf. A000040, A010051."
    ],
    "keyword": "nonn,easy,base",
    "offset": "1,1",
    "author": "_Paolo P. Lava_, Sep 26 2014",
    "references": 1,
    "revision": 26,
    "time": "2016-12-19T17:44:26-05:00",
    "created": "2014-09-26T21:40:57-04:00"
}