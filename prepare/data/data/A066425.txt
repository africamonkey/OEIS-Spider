{
    "number": 66425,
    "data": "1,3,8,18,41,84,181,364,751,1512,3037,6107,12216,24547,49117,98236,196544,393178,786407,1573201,3146426,6292969,12586763,25173709,50347996,100696725,201393664,402788102,805576428,1611153169,3222306562",
    "name": "Smallest increasing sequence (with a(1) = 1) such that a(n) minus any sum of distinct earlier terms is not already in the sequence.",
    "comment": [
        "Is there a closed or better recursive formula for a(n)? Can someone prove that a(n) > 2*a(n-1) for every n? Is there a polynomial-time algorithm for a(n)? The given Maple program is exponential in time and use of storage and hence not suitable to compute higher elements of the sequence.",
        "Proof that a(n) > 2*a(n-1) [AK, Feb 15 2002]: Each of the integers in range 1 .. a(n-1) can be represented as a sum of some subset of the terms {a(1),a(2),...,a(n-1)} plus at most one of the terms a(1)-a(n-1) added a second time (e.g., 16 = 8+8, 18 = 18, 22 = 18+3+1, 25 = 18+3+1+3, 28 = 18+8+1+1), thus each of the integers in the range a(n-1)+1 .. 2*a(n-1) can be represented as a similar \"dirty\" subset sum with also a(n-1) included, that is, there are no pure 1-subsets, i.e., no terms of A066425 in the latter range. Note that neither is 2*a(n-1) a possible candidate because it is a(n-1) + a(n-1)."
    ],
    "link": [
        "A. Karttunen, <a href=\"/A066425/a066425s.txt\">Scheme functions for computing A066425 and related sequences.</a>"
    ],
    "formula": [
        "a(1)=1, a(n) the smallest integer > a(n-1) so that a(n) - a(k_1) - a(k_2)- ... - a(k_m) is not in the sequence for any nonempty subset {k_1, ..., k_m} of {1, .., n-1}",
        "a(1)=1, a(n) = 2*a(n-1) + A068058(n-1). [AK]"
    ],
    "example": [
        "With a(1)=1 and a(2)=3 a(3) cannot be 4, 5, 6 or 7, since 4-a(1), 5-a(1)-a(2), 6-a(2) and 7-a(1)-a(2) are in the sequence, but 8-a(1), 8-a(2) and 8-a(1)-a(2) are not, hence a(3)=8."
    ],
    "maple": [
        "a(1) := 1: setofelms := {1}: setofsums := {1}: for n from 2 to 15 do: for i from a(n-1)+1 do: check := 0: for elsum in setofsums while check = 0 do: if member(i-elsum, setofelms) then check := 1: fi: od: if check = 1 then next: fi: a(n) := i: print (n, a(n)): setofsumsn := {}: for elsum in setofsums do: setofsumsn := setofsumsn union {elsum+a(n)}: od: setofsums := (setofsumsn union setofsums) union {a(n)}: setofelms := setofelms union {a(n)}: break: od: od:"
    ],
    "mathematica": [
        "(* This program is not convenient to compute a large number of terms *) a[1] = 1; a[n_] := a[n] = Module[{aa, sums, an, diffs}, sums = Total /@ Subsets[aa = Array[a, n-1], {2, Infinity}]; For[an = 2*a[n-1] + 1, True, an++, diffs = an - sums; If[Intersection[aa, diffs] == {}, Return[an]]]]; Table[Print[\"a(\", n, \") = \", a[n]]; a[n], {n, 1, 25}] (* _Jean-Fran\u00e7ois Alcover_, Sep 27 2013 *)"
    ],
    "program": [
        "(C++) #include <iostream> #include <vector> using namespace std ; int main(int argc, char *argv[]) { vector<unsigned long long> a ; a.push_back(1LL) ; for(;;) { int n = a.size() ; bool found= false ; for(unsigned long long nexta = 2LL*a[n-1]+1LL; !found ; nexta++) { bool foundComb=false ; for(unsigned long long bmask = 1LL<<n ; bmask > 0 && !foundComb; ) { bmask -- ; unsigned long long tstsum=0LL ; for(int maskpo=0; maskpo < n ; maskpo++) if ( (1LL << maskpo) & bmask) tstsum += a[maskpo] ; unsigned long long tstsumM=0LL ; if( tstsum == nexta) { foundComb=true ; break ; } for(int maskpo=0; maskpo < n && ! foundComb ; maskpo++) if ( (1 << maskpo) & bmask) { unsigned long long tstsum2 = tstsum+a[maskpo] ; tstsumM=max(tstsumM,tstsum2) ; if ( tstsum2 == nexta ) { foundComb=true ; break ; } } if( tstsumM < nexta) break ; } if ( foundComb==false ) { a.push_back(nexta) ; cout << nexta << endl ; found=true ; break ; } } } } /* _R. J. Mathar_, May 24 2006 */"
    ],
    "xref": [
        "Cf. A068054, A068055, A068056, A068057, A068058, A068059, A068221-A068224."
    ],
    "keyword": "nonn,nice",
    "offset": "1,2",
    "author": "Ulrich Schimke (ulrschimke(AT)aol.com), Dec 26 2001",
    "ext": [
        "Terms a(16)-a(21) computed (with the Scheme-code linked above) by _Antti Karttunen_, Feb 26 2002",
        "More terms from _John W. Layman_, Mar 19 2002",
        "More terms from _R. J. Mathar_, May 24 2006"
    ],
    "references": 9,
    "revision": 24,
    "time": "2017-11-20T05:39:13-05:00",
    "created": "2003-05-16T03:00:00-04:00"
}