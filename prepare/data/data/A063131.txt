{
    "number": 63131,
    "data": "55,91,215,407,493,893,1189,1343,1403,1643,1681,1961,3151,3223,3415,4063,4579,7087,7597,7979,8791,9167,10579,11227,13303,13655,14219,15487,16147,22939,23479,24341,25751,26101,27571,28757,30461,30607",
    "name": "Odd composite numbers which in base 2 contain their largest proper factor as a substring of digits.",
    "comment": [
        "The Pascal program checks to n=100000 in about a second on a 2GHz desktop, about three times as fast than the Mathematica program."
    ],
    "mathematica": [
        "Do[ If[ !PrimeQ[ n ] && StringPosition[ ToString[ FromDigits[ IntegerDigits[ n, 2 ] ] ], ToString[ FromDigits[ IntegerDigits[ Divisors[ n ] [ [ -2 ] ], 2 ] ] ] ] != {}, Print[ n ] ], {n, 3, 500, 2} ]"
    ],
    "program": [
        "(Pascal) program A063131; var n,nn,lpd:longint; nstr,dstr:string; function prime(n:longint; var d:longint):boolean; var sq,i:longint; begin{PRIME} sq := round(sqrt(n)); for i := 2 to sq do if n mod i=0 then begin d := n div i; prime := false; exit; end; prime := true; end{PRIME}; begin{MAIN} for n := 3 to 100000 do if (n mod 2=1) and (not prime(n,lpd)) then begin nn := n; nstr := ''; repeat if nn mod 2=1 then nstr := '1'+nstr else nstr := '0'+nstr; nn := nn div 2; until nn=0; dstr := ''; repeat if lpd mod 2=1 then dstr := '1'+dstr else dstr := '0'+dstr; lpd := lpd div 2; until lpd=0; if pos(dstr,nstr)>0 then write(n:8); end; end."
    ],
    "xref": [
        "Cf. A062238, A063127."
    ],
    "keyword": "base,nonn",
    "offset": "1,1",
    "author": "_Robert G. Wilson v_, Aug 08 2001",
    "ext": [
        "Extended and edited by _John W. Layman_, Apr 06 2002"
    ],
    "references": 2,
    "revision": 4,
    "time": "2012-03-30T17:37:51-04:00",
    "created": "2003-05-16T03:00:00-04:00"
}