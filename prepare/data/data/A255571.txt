{
    "number": 255571,
    "data": "1,64,65,126,127,1056,1057,1090,1091,1156,1157,1288,1289,1518,1519,1552,1553,1782,1783,1914,1915,1980,1981,2014,2015,4368,4369,4642,4643,5188,5189,6006,6007,6280,6281,7098,7099,7644,7645,7918,7919,16962,16963,17028,17029,17160,17161,17542,17543,17544,17545,17674,17675,17938,17939",
    "name": "Numbers whose binary representation traces a nonselfcrossing circuit in honeycomb lattice when its bits (from the least to the second most significant bit) are interpreted as directions to proceed at each vertex. (The most significant 1-bit is ignored).",
    "comment": [
        "Numbers n such that when we start scanning bits in the binary expansion of n, from the least to the most significant end, and when we interpret each bit as to a direction which to turn at each vertex (e.g., 0 = left, 1 = right) when traversing the edges of honeycomb lattice, then, when we have consumed all except the most significant 1-bit (which is ignored), we have eventually returned to the same vertex where we started from and none of the other vertices have been visited twice.",
        "Indexing starts from zero, because a(0) = 1 is a special case, indicating an empty path, which thus ends at the same vertex as where it started from.",
        "If n is a member, then A054429(n) is also a member."
    ],
    "link": [
        "Antti Karttunen, <a href=\"/A255571/b255571.txt\">Table of n, a(n) for n = 0..9300</a>",
        "Wikipedia, <a href=\"http://en.wikipedia.org/wiki/Honeycomb_lattice\">Hexagonal lattice</a>"
    ],
    "example": [
        "The examples given in A255570 occur also in this sequence, except that 380 (\"101111100\" in binary) is excluded from this sequence, because it visits twice the first vertex after the starting vertex."
    ],
    "program": [
        "(Scheme, with _Antti Karttunen_'s IntSeq-library)",
        "(define A255571 (MATCHING-POS 0 1 isA255571?))",
        "(define (isA255571? n) (let loop ((n n) (x 0) (y 0) (phase 0) (vv (list))) (cond ((= 1 n) (and (zero? x) (zero? y))) ((member (cons x y) vv) #f) (else (let* ((d (modulo n 2)) (newphase (modulo (+ phase d d -1) 6))) (loop (/ (- n d) 2) (+ x (x-delta newphase)) (+ y (y-delta newphase)) newphase (cons (cons x y) vv)))))))",
        "(define (newphase p d) (modulo (+ p d d -1) 6))",
        "(define (x-delta phase) (* (- (* 2 (floor->exact (/ phase 3))) 1) (- (modulo phase 3) 1)))",
        "(define (y-delta phase) (* (- 1 (* 2 (floor->exact (/ phase 3)))) (floor->exact (/ (+ 1 (modulo phase 3)) 2))))"
    ],
    "xref": [
        "Cf. A054429, A255561.",
        "Subsequence of A255570."
    ],
    "keyword": "nonn,base",
    "offset": "0,2",
    "author": "_Antti Karttunen_, Apr 13 2015",
    "references": 7,
    "revision": 17,
    "time": "2015-05-01T05:36:53-04:00",
    "created": "2015-04-30T21:43:29-04:00"
}