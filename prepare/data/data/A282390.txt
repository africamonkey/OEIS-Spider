{
    "number": 282390,
    "data": "3,5,8,14,27,53,104,206,410,818,1635,3269,6536,13070,26139,52277,104552,209102,418202,836402,1672803,3345605,6691209,13382417,26764832,53529662,107059322,214118642,428237283,856474565,1712949128,3425898254,6851796507",
    "name": "Width of polyominoes in A282389.",
    "comment": [
        "Polyominoes in A282389 have got a width of a(n+1) squares and a height of A000051(n) squares.",
        "The polyomino may be represented as a sequence of the lengths of steps in the \"ladder\" of the polyomino: [2, 1] for L-tetromino, [2, 1, 2] for the next iteration, and so on. The overall width is the sum of these lengths. And on the next iteration, the new sequence of lengths of steps is formed from the previous one as: <previous sequence, reversed, with the first (after reversion) element removed> + <previous sequence, reversed>. So the sequence always consists of 1's and 2's only and therefore can be encoded as a binary string of length 2^n+1. This is exploited in the Python program below and explains the formula. - _Andrey Zabolotskiy_, Feb 14 2017"
    ],
    "link": [
        "Andrey Zabolotskiy, <a href=\"/A282390/b282390.txt\">Table of n, a(n) for n = 1..3300</a>"
    ],
    "formula": [
        "a(1) = 3, a(n) = 2*a(n-1) - k for n > 1, where k is the width of the central step in the \"ladder\", which is 1 or 2."
    ],
    "example": [
        "a(1) = 3",
        "a(2) = 2 * 3 - 1 = 5",
        "a(3) = 2 * 5 - 2 = 8",
        "a(4) = 2 * 8 - 2 = 14",
        "a(5) = 2 * 14 - 1 = 27",
        "a(6) = 2 * 27 - 1 = 53",
        "a(7) = 2 * 53 - 2 = 104",
        "a(8) = 2 * 104 - 2 = 206",
        "a(9) = 2 * 206 - 2 = 410",
        "a(10) = 2 * 410 - 2 = 818",
        "a(11) = 2 * 818 - 1 = 1635",
        "a(12) = 2 * 1635 - 1 = 3269",
        "a(13) = 2 * 3269 - 2 = 6536",
        "a(14) = 2 * 6536 - 2 = 13070",
        "a(15) = 2 * 13070 - 1 = 26139",
        "a(16) = 2 * 26139 - 1 = 52277",
        "a(17) = 2 * 52277 - 2 = 104552",
        "a(18) = 2 * 104552 - 2 = 209102"
    ],
    "program": [
        "(Python)",
        "w, h, bp, bp2 = 3, 2, 0b10, 0b01",
        "for i in range(1, 10):",
        "    print(w)",
        "    w, h, bp, bp2 = w*2-(2 if (bp&1) else 1), 2**i+1, ((bp2&((1<<(h-1))-1))<<h)+bp2, (bp<<(h-1))+(bp>>1)",
        "for i in range(100):",
        "    print(w)",
        "    w, h, bp, bp2 = w*2-(2 if (bp&1) else 1), h-1, bp2, (bp>>1)",
        "# _Andrey Zabolotskiy_, Feb 14 2017"
    ],
    "xref": [
        "Cf. A282389."
    ],
    "keyword": "nonn",
    "offset": "1,1",
    "author": "_Daniel Poveda Parrilla_, Feb 14 2017",
    "references": 2,
    "revision": 21,
    "time": "2017-02-14T22:35:22-05:00",
    "created": "2017-02-14T22:35:22-05:00"
}